<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" ><generator uri="https://jekyllrb.com/" version="3.6.2">Jekyll</generator><link href="http://localhost:4000/feed.xml" rel="self" type="application/atom+xml" /><link href="http://localhost:4000/" rel="alternate" type="text/html" /><updated>2017-11-29T23:58:41+09:00</updated><id>http://localhost:4000/</id><entry><title type="html">BOJ 2579 계단 오르기</title><link href="http://localhost:4000/posts/2017/11/29/BOJ2579.html" rel="alternate" type="text/html" title="BOJ 2579  계단 오르기" /><published>2017-11-29T14:58:00+09:00</published><updated>2017-11-29T14:58:00+09:00</updated><id>http://localhost:4000/posts/2017/11/29/BOJ2579</id><content type="html" xml:base="http://localhost:4000/posts/2017/11/29/BOJ2579.html">&lt;p&gt;&lt;br /&gt;&lt;/p&gt;
&lt;h1 id=&quot;문제&quot;&gt;&lt;a href=&quot;https://www.acmicpc.net/problem/2579&quot;&gt;문제&lt;/a&gt;&lt;/h1&gt;

&lt;p&gt;&lt;br /&gt;
계단 오르기 게임은 계단 아래 시작점부터 계단 꼭대기에 위치한 도착점까지 가는 게임이다. &amp;lt;그림 1&amp;gt;과 같이 각각의 계단에는 일정한 점수가 쓰여 있는데 계단을 밟으면 그 계단에 쓰여 있는 점수를 얻게 된다.&lt;/p&gt;

&lt;p&gt;예를 들어 &amp;lt;그림 2&amp;gt;와 같이 시작점에서부터 첫 번째, 두 번째, 네 번째, 여섯 번째, 계단을 밟아 도착점에 도달하면 총 점수는 10 + 20 + 25 + 20 = 75점이 된다.&lt;/p&gt;

&lt;p&gt;계단 오르는 데는 다음과 같은 규칙이 있다.&lt;/p&gt;

&lt;p&gt;계단은 한 번에 한 계단씩 또는 두 계단씩 오를 수 있다. 즉, 한 계단을 밟으면서 이어서 다음 계단이나, 다음 다음 계단으로 오를 수 있다.
연속된 세 개의 계단을 모두 밟아서는 안된다. 단, 시작점은 계단에 포함되지 않는다.
마지막 도착 계단은 반드시 밟아야 한다.
따라서 첫 번째 계단을 밟고 이어 두 번째 계단이나, 세 번째 계단으로 오를 수 있다. 하지만, 첫 번째 계단을 밟고 이어 네 번째 계단으로 올라가거나, 첫 번째, 두 번째, 세번째 계단을 연속해서 모두 밟을 수는 없다.&lt;/p&gt;

&lt;p&gt;각 계단에 쓰여 있는 점수가 주어질 때 이 게임에서 얻을 수 있는 총 점수의 최대값을 구하는 프로그램을 작성하시오.
&lt;br /&gt;&lt;/p&gt;
&lt;h1 id=&quot;입력&quot;&gt;입력&lt;/h1&gt;
&lt;p&gt;&lt;br /&gt;
입력의 첫째 줄에 계단의 개수가 주어진다.&lt;/p&gt;

&lt;p&gt;둘째 줄부터 한 줄에 하나씩 제일 아래에 놓인 계단부터 순서대로 각 계단에 쓰여 있는 점수가 주어진다. 계단의 개수는 300이하의 자연수이고, 계단에 쓰여 있는 점수는 10,000이하의 자연수이다.
&lt;br /&gt;&lt;/p&gt;
&lt;h1 id=&quot;출력&quot;&gt;출력&lt;/h1&gt;
&lt;p&gt;&lt;br /&gt;
첫째 줄에 계단 오르기 게임에서 얻을 수 있는 총 점수의 최대값을 출력한다.
&lt;br /&gt;&lt;/p&gt;
&lt;h1 id=&quot;해결-방법&quot;&gt;해결 방법&lt;/h1&gt;
&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;앞서 포스팅한 2156번 포도주 시식 문제와 매우 유사하다.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;다른 점은 포도주 시식의 경우 최대값을 위해서는 연속해서 2잔 이상을 마시지 않아도 되지만 계단 오르기의 경우 한잔만 건너뛸 수 있다.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;각 위치의 계단은 세가지의 경우를 가진다.
0 = 밟지 않는다. (아래의 계단을 밟았어야한다.)
1 = 아래의 계단은 밟지않고, 이번 계단만 밟는다. (즉, 2계단 위를 밟았다.)
2 = 아래의 계단을 밟고, 이번 계단도 밟는다. (즉, 1계단 위를 밟는다.)&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;위의 세가지 경우를 데이터에 저장하고, 이를 이용하여 최대값을 구하면 된다.&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;
&lt;h1 id=&quot;코드&quot;&gt;코드&lt;/h1&gt;
&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;#include &amp;lt;iostream&amp;gt;

using namespace std;

int dp[301][3];
int stairs[301];

int main(){
  int n;
  cin&amp;gt;&amp;gt;n;
  for(int i =1;i&amp;lt;=n;i++)
    cin&amp;gt;&amp;gt;stairs[i];

  for(int i=1;i&amp;lt;n;i++){
    dp[i][0] = max(dp[i-1][1],dp[i-1][2]); // i 위치는 밟지 않는 경우 //한 계단 or 두 계단 전은 밟아야함
    dp[i][1] = dp[i-1][0]+stairs[i]; //밟는 경우 중 연속 계수가 1
    dp[i][2] = dp[i-1][1]+stairs[i]; // 밟는 경우 중 연속 계수가 2
  }
  int result =  max(dp[n-1][1],dp[n-1][0]) + stairs[n];
  cout&amp;lt;&amp;lt;result&amp;lt;&amp;lt;&quot;\n&quot;;

}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;</content><author><name></name></author><summary type="html">문제</summary></entry><entry><title type="html">BOJ 2156 포도주 시식</title><link href="http://localhost:4000/posts/2017/11/29/BOJ2156.html" rel="alternate" type="text/html" title="BOJ 2156 포도주 시식" /><published>2017-11-29T14:51:00+09:00</published><updated>2017-11-29T14:51:00+09:00</updated><id>http://localhost:4000/posts/2017/11/29/BOJ2156</id><content type="html" xml:base="http://localhost:4000/posts/2017/11/29/BOJ2156.html">&lt;p&gt;&lt;br /&gt;&lt;/p&gt;
&lt;h1 id=&quot;문제&quot;&gt;&lt;a href=&quot;https://www.acmicpc.net/problem/2156&quot;&gt;문제&lt;/a&gt;&lt;/h1&gt;

&lt;p&gt;&lt;br /&gt;
효주는 포도주 시식회에 갔다. 그 곳에 갔더니, 테이블 위에 다양한 포도주가 들어있는 포도주 잔이 일렬로 놓여 있었다. 효주는 포도주 시식을 하려고 하는데, 여기에는 다음과 같은 두 가지 규칙이 있다.&lt;/p&gt;

&lt;p&gt;포도주 잔을 선택하면 그 잔에 들어있는 포도주는 모두 마셔야 하고, 마신 후에는 원래 위치에 다시 놓아야 한다.
연속으로 놓여 있는 3잔을 모두 마실 수는 없다.
효주는 될 수 있는 대로 많은 양의 포도주를 맛보기 위해서 어떤 포도주 잔을 선택해야 할지 고민하고 있다. 1부터 n까지의 번호가 붙어 있는 n개의 포도주 잔이 순서대로 테이블 위에 놓여 있고, 각 포도주 잔에 들어있는 포도주의 양이 주어졌을 때, 효주를 도와 가장 많은 양의 포도주를 마실 수 있도록 하는 프로그램을 작성하시오.&lt;/p&gt;

&lt;p&gt;예를 들어 6개의 포도주 잔이 있고, 각각의 잔에 순서대로 6, 10, 13, 9, 8, 1 만큼의 포도주가 들어 있을 때, 첫 번째, 두 번째, 네 번째, 다섯 번째 포도주 잔을 선택하면 총 포도주 양이 33으로 최대로 마실 수 있다.
&lt;br /&gt;&lt;/p&gt;
&lt;h1 id=&quot;입력&quot;&gt;입력&lt;/h1&gt;
&lt;p&gt;&lt;br /&gt;
첫째 줄에 포도주 잔의 개수 n이 주어진다. (1≤n≤10,000) 둘째 줄부터 n+1번째 줄까지 포도주 잔에 들어있는 포도주의 양이 순서대로 주어진다. 포도주의 양은 1,000 이하의 음이 아닌 정수이다.
&lt;br /&gt;&lt;/p&gt;
&lt;h1 id=&quot;출력&quot;&gt;출력&lt;/h1&gt;
&lt;p&gt;&lt;br /&gt;
첫째 줄에 최대로 마실 수 있는 포도주의 양을 출력한다.
&lt;br /&gt;&lt;/p&gt;
&lt;h1 id=&quot;해결-방법&quot;&gt;해결 방법&lt;/h1&gt;
&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;n에 들어 올 수 잇는 수는 1&amp;lt;=n&amp;lt;=10,000 이개 때문에 O(n^2)으로 할 경우에 시간 초과가 발생한다.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;그렇다면 포도주를 마시면서 그것의 대한 값을 데이터 저정해야한다.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;각 위치의 포도주는 세가지의 경우를 가진다. 0 = 마시지 않는다.
1 = 바로 왼쪽 옆 잔은 마시지 않았으나 이번 잔은 마신다.
2 = 바로 왼쪽 옆 잔도 마셨고, 이번 잔도 마신다 (단,왼쪽으로 두번째 옆 잔은 마시지 않았다.)&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;위의 세가지 경우를 데이터에 저장하고, 이를 이용하여 최대값을 구하면 된다.&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;
&lt;h1 id=&quot;코드&quot;&gt;코드&lt;/h1&gt;
&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;#include &amp;lt;iostream&amp;gt;
#include &amp;lt;algorithm&amp;gt;
using namespace std;

int dp[10001][4];
int wine_data[10001];

int main(){
	int wine_count;
	cin&amp;gt;&amp;gt;wine_count;
	for(int i=1;i&amp;lt;=wine_count;i++)
		cin&amp;gt;&amp;gt;wine_data[i];
	for(int i=1;i&amp;lt;=wine_count;i++){
		dp[i][0]= dp[i-1][3];
		dp[i][1]= dp[i-1][0]+wine_data[i];
		dp[i][2]= dp[i-1][1]+wine_data[i];
		dp[i][3]= max(dp[i][0],max(dp[i][1],dp[i][2]));
	}

	cout&amp;lt;&amp;lt;dp[wine_count][3]&amp;lt;&amp;lt;&quot;\n&quot;;

}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;</content><author><name></name></author><summary type="html">문제</summary></entry><entry><title type="html">BOJ 9095 1,2,3 더하기</title><link href="http://localhost:4000/posts/2017/11/28/BOJ9095.html" rel="alternate" type="text/html" title="BOJ 9095 1,2,3 더하기" /><published>2017-11-28T07:51:00+09:00</published><updated>2017-11-28T07:51:00+09:00</updated><id>http://localhost:4000/posts/2017/11/28/BOJ9095</id><content type="html" xml:base="http://localhost:4000/posts/2017/11/28/BOJ9095.html">&lt;p&gt;&lt;br /&gt;&lt;/p&gt;
&lt;h1 id=&quot;문제&quot;&gt;&lt;a href=&quot;https://www.acmicpc.net/problem/9095&quot;&gt;문제&lt;/a&gt;&lt;/h1&gt;
&lt;p&gt;&lt;br /&gt;
정수 4를 1, 2, 3의 조합으로 나타내는 방법은 총 7가지가 있다.&lt;/p&gt;

&lt;p&gt;1+1+1+1
1+1+2
1+2+1
2+1+1
2+2
1+3
3+1
정수 n이 주어졌을 때, n을 1,2,3의 합으로 나타내는 방법의 수를 구하는 프로그램을 작성하시오.
&lt;br /&gt;&lt;/p&gt;
&lt;h1 id=&quot;입력&quot;&gt;입력&lt;/h1&gt;
&lt;p&gt;&lt;br /&gt;
첫쨰 줄에 테스트 케이스의 개수 T가 주어진다. 각 테스트 케이스는 한 줄로 이루어져 있고, 정수 n이 주어진다. n은 양수이며 11보다 작다.
&lt;br /&gt;&lt;/p&gt;
&lt;h1 id=&quot;출력&quot;&gt;출력&lt;/h1&gt;
&lt;p&gt;&lt;br /&gt;
각 테스트 케이스마다, n을 1,2,3의 합으로 나타내는 방법의 수를 출력한다.
&lt;br /&gt;&lt;/p&gt;
&lt;h1 id=&quot;해결-방법&quot;&gt;해결 방법&lt;/h1&gt;
&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;1,2,3을 이용하여 1~11 가지의 숫자의 경우의 수를 구하는 것이다. 여기서 포인트는 무엇보다 숫자에 순서가 중요하다는 것이다. 그것을 이용하면 쉽게 문제를 해결할 수 있다.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;예로 나와있듯이 4를 구성하는 경우는 총 7가지가 존재한다.
이것을 보면 3을 구성하는 경우의수와 2를 구성하는 경우의 수와 1을 구성하는 경우의 수를 더한 값과 같다.&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;
&lt;h1 id=&quot;코드&quot;&gt;코드&lt;/h1&gt;
&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;#include &amp;lt;iostream&amp;gt;
#include &amp;lt;string&amp;gt;

using namespace std;
int dp[11];
int num[3]={1,2,3};

int main(){
  dp[0] = 0;

  int n;
  cin &amp;gt;&amp;gt;n;

  for(int i=1;i&amp;lt;11;i++){
    for(int j=0;j&amp;lt;3;j++){
      if( i - num[j] &amp;gt;= 1){
        dp[i]+= dp[i-num[j]];
      }
      if(num[j]==i){
        dp[i]+=1;
      }
    }
  }
  for (int i = 0; i &amp;lt; n; i++) {
	  int temp;
	  cin &amp;gt;&amp;gt; temp;
	  cout &amp;lt;&amp;lt; dp[temp] &amp;lt;&amp;lt; &quot;\n&quot;;
  }

}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;</content><author><name></name></author><summary type="html">문제 정수 4를 1, 2, 3의 조합으로 나타내는 방법은 총 7가지가 있다.</summary></entry><entry><title type="html">BOJ 2133 타일 채우기</title><link href="http://localhost:4000/posts/2017/11/27/BOJ2133.html" rel="alternate" type="text/html" title="BOJ 2133 타일 채우기" /><published>2017-11-27T08:51:00+09:00</published><updated>2017-11-27T08:51:00+09:00</updated><id>http://localhost:4000/posts/2017/11/27/BOJ2133</id><content type="html" xml:base="http://localhost:4000/posts/2017/11/27/BOJ2133.html">&lt;p&gt;&lt;br /&gt;&lt;/p&gt;
&lt;h1 id=&quot;문제&quot;&gt;&lt;a href=&quot;https://www.acmicpc.net/problem/2133&quot;&gt;문제&lt;/a&gt;&lt;/h1&gt;
&lt;p&gt;&lt;br /&gt;
3×N 크기의 벽을 2×1, 1×2 크기의 타일로 채우는 경우의 수를 구해보자.
&lt;br /&gt;&lt;/p&gt;
&lt;h1 id=&quot;입력&quot;&gt;입력&lt;/h1&gt;
&lt;p&gt;&lt;br /&gt;
첫째 줄에 N(1 ≤ N ≤ 30)이 주어진다.
&lt;br /&gt;&lt;/p&gt;
&lt;h1 id=&quot;출력&quot;&gt;출력&lt;/h1&gt;
&lt;p&gt;&lt;br /&gt;
첫째 줄에 경우의 수를 출력한다.
&lt;br /&gt;&lt;/p&gt;
&lt;h1 id=&quot;해결-방법&quot;&gt;해결 방법&lt;/h1&gt;
&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;홀수 일때의 값은 신경쓸 필요가 없다. 모든 홀수의 경우는 0이다.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;N = 2 일때, 3개의 경우의 수가 발생하고, 3×2 타일을 이어 붙였을 때, 경계에서 2개의 새로운 경우의 수가 발생한다. 이 새로운 경우를 F케이스로 명명하자.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;즉, 각 N 값은 3×N-2 를 완성한 경우에서 3×2 타일의 붙이는 경우의 수와 N-j (4&amp;lt;=j&amp;lt;=N (j+2))인 K케이스에  발생하는 경우의 수를 합하면 해결된다.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;6을 예로 하면, 3×4 타일의 경우의 수인 11 *3 과 3x4타일에 새로운 타일을 붙일 때 만들어지는 K케이스는 3x4타일에서 K케이스가 없을 때와 있을 때로 나누어 보면 3 *2 + 1 *2 의 값이 나온다.&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;
&lt;h1 id=&quot;코드&quot;&gt;코드&lt;/h1&gt;
&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;#include &amp;lt;iostream&amp;gt;
using namespace std;

int index[31];

int main() {
	int n = 0;
	cin &amp;gt;&amp;gt; n;

	int result = 0;
	index[0] = 1;
	index[2] = 3;
	
	for (int i = 4; i &amp;lt;= n; i += 2) {
		index[i] += index[i - 2] * index[2]; // 3*i-2로 만들어진 타일에 3*2의 타일을 추가할 경우의 수

		for (int j = 4; j &amp;lt;= i; j++) {
			index[i] += index[i - j] * 2; // 3*2타일들이 붙었을 때, 그 사이에 2개 만큼의 경우의 수가 추가 발생
		}
	}
	cout &amp;lt;&amp;lt; index[n];
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;</content><author><name></name></author><summary type="html">문제 3×N 크기의 벽을 2×1, 1×2 크기의 타일로 채우는 경우의 수를 구해보자. 입력 첫째 줄에 N(1 ≤ N ≤ 30)이 주어진다. 출력 첫째 줄에 경우의 수를 출력한다. 해결 방법</summary></entry><entry><title type="html">BOJ 14501 퇴사</title><link href="http://localhost:4000/posts/2017/11/21/BOJ14501.html" rel="alternate" type="text/html" title="BOJ 14501 퇴사" /><published>2017-11-21T14:30:00+09:00</published><updated>2017-11-21T14:30:00+09:00</updated><id>http://localhost:4000/posts/2017/11/21/BOJ14501</id><content type="html" xml:base="http://localhost:4000/posts/2017/11/21/BOJ14501.html">&lt;p&gt;&lt;br /&gt;&lt;/p&gt;
&lt;h1 id=&quot;문제&quot;&gt;&lt;a href=&quot;https://www.acmicpc.net/problem/14501&quot;&gt;문제&lt;/a&gt;&lt;/h1&gt;
&lt;p&gt;&lt;br /&gt;
상담원으로 일하고 있는 백준이는 퇴사를 하려고 한다.&lt;/p&gt;

&lt;p&gt;오늘부터 N+1일째 되는날 퇴사를 하기 위해서, 남은 N일 동안 최대한 많은 상담을 하려고 한다.&lt;/p&gt;

&lt;p&gt;백준이는 비서에게 최대한 많은 상담을 잡으라고 부탁을 했고, 비서는 하루에 하나씩 서로 다른 사람의 상담을 잡아놓았다.&lt;/p&gt;

&lt;p&gt;각각의 상담은 상담을 완료하는데 걸리는 기간 Ti와 상담을 했을 때 받을 수 있는 금액 Pi로 이루어져 있다.&lt;/p&gt;

&lt;p&gt;N = 7인 경우에 다음과 같은 상담 일정표를 보자.
&lt;br /&gt;&lt;br /&gt;&lt;/p&gt;
&lt;pre&gt;
 	1일	2일	3일	4일	5일	6일	7일
Ti	3	5	1	1	2	4	2
Pi	10	20	10	20	15	40	200
&lt;/pre&gt;
&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;1일에 잡혀있는 상담은 총 3일이 걸리며, 상담했을 때 받을 수 있는 금액은 10이다. 5일에 잡혀있는 상담은 총 2일이 걸리며, 받을 수 있는 금액은 15이다.&lt;/p&gt;

&lt;p&gt;상담을 하는데 필요한 기간은 1일보다 클 수 있기 때문에, 모든 상담을 할 수는 없다. 예를 들어서 1일에 상담을 하게 되면, 2일, 3일에 있는 상담은 할 수 없게 된다. 2일에 있는 상담을 하게 되면, 3, 4, 5, 6일에 잡혀있는 상담은 할 수 없다.&lt;/p&gt;

&lt;p&gt;또한, N+1일 째에는 회사에 없기 때문에, 6, 7일에 있는 상담을 할 수 없다.&lt;/p&gt;

&lt;p&gt;퇴사 전에 할 수 있는 상담의 최대 이익은 1일, 4일, 5일에 있는 상담을 하는 것이며, 이 때의 이익은 10+20+15=45이다.&lt;/p&gt;

&lt;p&gt;상담을 적절히 했을 때, 백준이가 얻을 수 있는 최대 수익을 구하는 프로그램을 작성하시오.
&lt;br /&gt;&lt;/p&gt;
&lt;h1 id=&quot;입력&quot;&gt;입력&lt;/h1&gt;
&lt;p&gt;&lt;br /&gt;
첫째 줄에 N (1 ≤ N ≤ 15)이 주어진다.&lt;/p&gt;

&lt;p&gt;둘째 줄부터 N개의 줄에 Ti와 Pi가 공백으로 구분되어서 주어지며, 1일부터 N일까지 순서대로 주어진다. (1 ≤ Ti ≤ 5, 1 ≤ Pi ≤ 1,000)
&lt;br /&gt;&lt;/p&gt;
&lt;h1 id=&quot;출력&quot;&gt;출력&lt;/h1&gt;
&lt;p&gt;&lt;br /&gt;
첫째 줄에 백준이가 얻을 수 있는 최대 이익을 출력한다.
&lt;br /&gt;&lt;/p&gt;
&lt;h1 id=&quot;해결-방법&quot;&gt;해결 방법&lt;/h1&gt;
&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;최대 이익을 찾으려는 것이다. 근데 데이터 셋이 크지 않다는 것이 이번 문제를 푸는 가장 쉬운 접근 법이다. 즉, 완전 탐색을 해도 된다는 것이다. 하지만 그래도 효율적으로 접근하기위해 배열에 값을 저장하여 사용하는 DP의 방법인 메모리제이션을 이용하였다.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;점화식으로 포문을 이용하여서 푸는 방법이 내 생각에는 더 효율적으로 보이지만 점화식을 잘 모르겠다.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;디피의 0번째 부터 채워가는 바텀업도 아니구, 끝에서 부터 만들어 나가는 탑다운도 아니다. 그냥 재귀호출을 통해 해결해나가는 것이고, 어떻게 보면 깊이우선탐색으로도 보일 수 있다.&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;
&lt;h1 id=&quot;코드&quot;&gt;코드&lt;/h1&gt;
&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;import java.util.Scanner;

public class BOJ14501 {

static int[][] dp;
static int[][] data;
static int day;
public static void main(String args[]){
    Scanner sc = new Scanner(System.in);
    day = sc.nextInt();
    dp = new int[day+1][2];
    data = new int[day][2];

    for(int i=0;i&amp;lt;day;i++){
        data[i][0]= sc.nextInt();
        data[i][1]= sc.nextInt();
        dp[i][0]=-1;
        dp[i][1]=-1;
    }
    int result = 0;

    result = DFS(0);
    System.out.println(result);
    sc.close();
}

static int DFS(int index){
    int result=0;

    if(dp[index][0]!=-1){
        if(dp[index][0]&amp;gt;dp[index][1]){
            return  dp[index][0];
        }else return dp[index][1];
    }

    if(index-1 &amp;gt;= day){
        return 0;
    }

    dp[index][0] = DFS(index+1);
    if(data[index][0]+index-1 &amp;lt; day) {
        dp[index][1] = DFS(index + data[index][0]) + data[index][1];
    }else{
        dp[index][1] = 0;
    }

    if(dp[index][0]&amp;gt;dp[index][1]){
        result += dp[index][0];
    }else result+= dp[index][1];

    return result;
} }
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;</content><author><name></name></author><summary type="html">문제 상담원으로 일하고 있는 백준이는 퇴사를 하려고 한다.</summary></entry><entry><title type="html">BOJ 2293 동전 1</title><link href="http://localhost:4000/posts/2017/11/20/BOJ2293.html" rel="alternate" type="text/html" title="BOJ 2293 동전 1" /><published>2017-11-20T07:30:00+09:00</published><updated>2017-11-20T07:30:00+09:00</updated><id>http://localhost:4000/posts/2017/11/20/BOJ2293</id><content type="html" xml:base="http://localhost:4000/posts/2017/11/20/BOJ2293.html">&lt;p&gt;&lt;br /&gt;&lt;/p&gt;
&lt;h1 id=&quot;문제&quot;&gt;&lt;a href=&quot;https://www.acmicpc.net/problem/2293&quot;&gt;문제&lt;/a&gt;&lt;/h1&gt;
&lt;p&gt;&lt;br /&gt;
n가지 종류의 동전이 있다. 각각의 동전이 나타내는 가치는 다르다. 이 동전들을 적당히 사용해서, 그 가치의 합이 k원이 되도록 하고 싶다. 그 경우의 수를 구하시오. (각각의 동전은 몇 개라도 사용할 수 있다.)
&lt;br /&gt;&lt;/p&gt;
&lt;h1 id=&quot;입력&quot;&gt;입력&lt;/h1&gt;
&lt;p&gt;&lt;br /&gt;
첫째줄에 n, k가 주어진다. (1 ≤ n ≤ 100, 1 ≤ k ≤ 10,000) 다음 n개의 줄에는 각각의 동전의 가치가 주어진다.
&lt;br /&gt;&lt;/p&gt;
&lt;h1 id=&quot;출력&quot;&gt;출력&lt;/h1&gt;
&lt;p&gt;&lt;br /&gt;
첫째 줄에 경우의 수를 출력한다. 경우의 수는 2^31보다 작다.
&lt;br /&gt;&lt;/p&gt;
&lt;h1 id=&quot;해결-방법&quot;&gt;해결 방법&lt;/h1&gt;
&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;찾으려는 수는 (찾으려는 수 - 동전의 값) 들의 합이다.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;중복이 되면 안된다.&lt;/p&gt;
    &lt;blockquote&gt;
      &lt;p&gt;예를 들어 1과 2로 5를 만들려고 할때, 1112 1121 1211 2111 은 순서 다르고 다 같은 값을 만들게 된다. 따라서 중복을 제거하기 위해 중복을 안만드는 방법을 선택하였다. &lt;br /&gt;
그 방법은 가장 값이 낮은 동전 부터 배열을 채워나가는 것이다.&lt;/p&gt;
    &lt;/blockquote&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;
&lt;h1 id=&quot;코드&quot;&gt;코드&lt;/h1&gt;
&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;

public class Main {

static int[] dp;
static int[] coins;
static int coinsCounts;
public static void main(String args[]) throws IOException{
    dp = new int [10001];
    for(int i=0;i&amp;lt;10001;i++){
        dp[i] = 0;
    }

    BufferedReader bf = new BufferedReader(new InputStreamReader(System.in));

    String[] line = bf.readLine().split(&quot; &quot;);
    coinsCounts = Integer.valueOf(line[0]);
    int findValue = Integer.valueOf(line[1]);
    coins = new int[coinsCounts];

    for(int i=0;i&amp;lt; coinsCounts;i++){
        coins[i] = Integer.valueOf(bf.readLine());
    }
    dp[0] = 1;
    for(int i=0;i &amp;lt; coinsCounts;i++){
        for(int j=1;j&amp;lt;= findValue ;j++){
            if(j-coins[i] &amp;gt;= 0){
                dp[j] += dp[j-coins[i]];
            }
        }
    }

    System.out.println(dp[findValue]);
    bf.close();
}	
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;</content><author><name></name></author><summary type="html">문제 n가지 종류의 동전이 있다. 각각의 동전이 나타내는 가치는 다르다. 이 동전들을 적당히 사용해서, 그 가치의 합이 k원이 되도록 하고 싶다. 그 경우의 수를 구하시오. (각각의 동전은 몇 개라도 사용할 수 있다.) 입력 첫째줄에 n, k가 주어진다. (1 ≤ n ≤ 100, 1 ≤ k ≤ 10,000) 다음 n개의 줄에는 각각의 동전의 가치가 주어진다. 출력 첫째 줄에 경우의 수를 출력한다. 경우의 수는 2^31보다 작다. 해결 방법</summary></entry><entry><title type="html">About this blog</title><link href="http://localhost:4000/posts/2017/11/18/about.html" rel="alternate" type="text/html" title="About this blog" /><published>2017-11-19T03:30:00+09:00</published><updated>2017-11-19T03:30:00+09:00</updated><id>http://localhost:4000/posts/2017/11/18/about</id><content type="html" xml:base="http://localhost:4000/posts/2017/11/18/about.html">&lt;h2 id=&quot;introducing-flex-a-jekyll-theme&quot;&gt;Introducing Flex, a Jekyll theme&lt;/h2&gt;

&lt;p&gt;Flex is a minimalist, responsive theme based on the website, &lt;a href=&quot;http://thedevelopment.co&quot;&gt;The Development&lt;/a&gt;.&lt;/p&gt;

&lt;h2 id=&quot;open-sourced-on-github&quot;&gt;Open Sourced on GitHub&lt;/h2&gt;

&lt;p&gt;Flex is open sourced on GitHub and is licensed under the &lt;a href=&quot;http://opensource.org/licenses/MIT&quot;&gt;MIT License&lt;/a&gt;. Feel free to contribute to it anytime!&lt;/p&gt;

&lt;h2 id=&quot;reference&quot;&gt;Reference&lt;/h2&gt;

&lt;p&gt;The theme currently being used was based on &lt;a href=&quot;https://github.com/the-development/flex&quot;&gt;this&lt;/a&gt;&lt;/p&gt;</content><author><name></name></author><summary type="html">Introducing Flex, a Jekyll theme</summary></entry></feed>