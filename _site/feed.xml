<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" ><generator uri="https://jekyllrb.com/" version="3.6.2">Jekyll</generator><link href="http://localhost:4000/feed.xml" rel="self" type="application/atom+xml" /><link href="http://localhost:4000/" rel="alternate" type="text/html" /><updated>2017-12-03T23:48:48+09:00</updated><id>http://localhost:4000/</id><entry><title type="html">BOJ 14502 연구소</title><link href="http://localhost:4000/posts/2017/12/03/BOJ14502.html" rel="alternate" type="text/html" title="BOJ 14502 연구소" /><published>2017-12-03T14:38:00+09:00</published><updated>2017-12-03T14:38:00+09:00</updated><id>http://localhost:4000/posts/2017/12/03/BOJ14502</id><content type="html" xml:base="http://localhost:4000/posts/2017/12/03/BOJ14502.html">&lt;p&gt;&lt;br /&gt;&lt;/p&gt;
&lt;h1 id=&quot;문제&quot;&gt;&lt;a href=&quot;https://www.acmicpc.net/problem/14502&quot;&gt;문제&lt;/a&gt;&lt;/h1&gt;

&lt;p&gt;&lt;br /&gt;
인체에 치명적인 바이러스를 연구하던 연구소에서 바이러스가 유출되었다. 다행히 바이러스는 아직 퍼지지 않았고, 바이러스의 확산을 막기 위해서 연구소에 벽을 세우려고 한다.&lt;/p&gt;

&lt;p&gt;연구소는 크기가 N×M인 직사각형으로 나타낼 수 있으며, 직사각형은 1×1 크기의 정사각형으로 나누어져 있다. 연구소는 빈 칸, 벽으로 이루어져 있으며, 벽은 칸 하나를 가득 차지한다.&lt;/p&gt;

&lt;p&gt;일부 칸은 바이러스가 존재하며, 이 바이러스는 인접한 빈 칸으로 모두 퍼져나갈 수 있다. 새로 세울 수 있는 벽의 개수는 3개이며, 꼭 3개를 세워야 한다.&lt;/p&gt;

&lt;p&gt;예를 들어, 아래와 같이 연구소가 생긴 경우를 살펴보자.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;2 0 0 0 1 1 0
0 0 1 0 1 2 0
0 1 1 0 1 0 0
0 1 0 0 0 0 0
0 0 0 0 0 1 1
0 1 0 0 0 0 0
0 1 0 0 0 0 0
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;이 때, 0은 빈 칸, 1은 벽, 2는 바이러스가 있는 곳이다. 아무런 벽을 세우지 않는다면, 바이러스는 모든 빈 칸으로 퍼져나갈 수 있다.&lt;/p&gt;

&lt;p&gt;2행 1열, 1행 2열, 4행 6열에 벽을 세운다면 지도의 모양은 아래와 같아지게 된다.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;2 1 0 0 1 1 0
1 0 1 0 1 2 0
0 1 1 0 1 0 0
0 1 0 0 0 1 0
0 0 0 0 0 1 1
0 1 0 0 0 0 0
0 1 0 0 0 0 0
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;바이러스가 퍼진 뒤의 모습은 아래와 같아진다.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;2 1 0 0 1 1 2
1 0 1 0 1 2 2
0 1 1 0 1 2 2
0 1 0 0 0 1 2
0 0 0 0 0 1 1
0 1 0 0 0 0 0
0 1 0 0 0 0 0
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;벽을 3개 세운 뒤, 바이러스가 퍼질 수 없는 곳을 안전 영역이라고 한다. 위의 지도에서 안전 영역의 크기는 27이다.&lt;/p&gt;

&lt;p&gt;연구소의 지도가 주어졌을 때 얻을 수 있는 안전 영역 크기의 최대값을 구하는 프로그램을 작성하시오.
&lt;br /&gt;&lt;/p&gt;
&lt;h1 id=&quot;입력&quot;&gt;입력&lt;/h1&gt;
&lt;p&gt;&lt;br /&gt;
첫째 줄에 지도의 세로 크기 N과 가로 크기 M이 주어진다. (3 ≤ N, M ≤ 8)&lt;/p&gt;

&lt;p&gt;둘째 줄부터 N개의 줄에 지도의 모양이 주어진다. 0은 빈 칸, 1은 벽, 2는 바이러스가 있는 위치이다. 2의 개수는 2보다 크거나 같고, 10보다 작거나 같은 자연수이다.&lt;/p&gt;

&lt;p&gt;빈 칸의 개수는 3개 이상이다.
&lt;br /&gt;&lt;/p&gt;
&lt;h1 id=&quot;출력&quot;&gt;출력&lt;/h1&gt;
&lt;p&gt;&lt;br /&gt;
첫째 줄에 얻을 수 있는 안전 영역의 최대 크기를 출력한다.
&lt;br /&gt;&lt;/p&gt;
&lt;h1 id=&quot;해결-방법&quot;&gt;해결 방법&lt;/h1&gt;
&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;규칙도 방법도 찾을 수 없다. 있다하더라도 상당히 어려울 것으로 보인다. 따라서 모든 케이스를 다 해보는 완전 탐색을 생각했습니다. 이때 시간 복잡도는 최악일 경우에 (n^2)C3 * n^2 * x 로 O(n^8)으로 생각하였고,  (n&amp;lt;=8)이기에 1초가 걸리지 않는다고 생각했습니다.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;구현을 어떻게 하면 좋을 지가 좀 포인트라고 생각합니다. 저는 매 경우마다 virus_map을 초기 데이터 상태로 시작하는 것으로 처리하였고, 또한 visited를 사용하지 않고, 바이러스가 발생한 곳들을 3으로 대입 하였습니다.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;바이러스가 감염되는 것에 대해서는 BFS를 구현하였습니다.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;아쉬운 점이 있다면, 멍청하게 x&lt;em&gt;10+y로 저장하고 x/10 와 y/10 를 통해 복구하였는 데 n이 8이기 때문에 크기가 64&lt;/em&gt;2인 이차원 배열을 만들어서 사용하면 더 빠른 속도로 할 수 있을거라고 생각합니다.&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;
&lt;h1 id=&quot;코드&quot;&gt;코드&lt;/h1&gt;
&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;#include &amp;lt;iostream&amp;gt;
#include &amp;lt;vector&amp;gt;
#include &amp;lt;deque&amp;gt;
#include &amp;lt;algorithm&amp;gt;
using namespace std;

int n, m;
int virus_data[8][8];
int virus_map[8][8];
int move_[4][2] = { {1,0}, {-1,0}, {0,1}, {0,-1} };


void init_map() {
	for (int i = 0; i &amp;lt; n; i++) 
		for (int j = 0; j &amp;lt; m; j++)
			virus_map[i][j] = virus_data[i][j];
}

void bfs(int x,int y) {
	deque&amp;lt;int&amp;gt; bfsque;
	virus_map[x][y] = 3;
	bfsque.push_back(10*x+y);

	while(!bfsque.empty()) {
		int i = bfsque.front() / 10;
		int j = bfsque.front() % 10;
		bfsque.pop_front();
		for (int k = 0; k &amp;lt; 4; k++) {
			int x_ = i + move_[k][0];
			int y_ = j + move_[k][1];

			if (x_ &amp;gt;= 0 &amp;amp;&amp;amp; x_ &amp;lt; n &amp;amp;&amp;amp; y_ &amp;gt;= 0 &amp;amp;&amp;amp; y_ &amp;lt; m) {
				if (virus_map[x_][y_] == 0 || virus_map[x_][y_] == 2)
				{
					bfsque.push_back(x_ * 10 + y_);
					virus_map[x_][y_] = 3;
				}
			}
		}
	}

}

int safety_zone(){
	for (int i = 0; i &amp;lt; n; i++) {
		for (int j = 0; j &amp;lt; m; j++) {
			if (virus_map[i][j] == 2)
				bfs(i, j);
		}
	}
	int count_zero=0;
	for (int i = 0; i &amp;lt; n; i++) {
		for (int j = 0; j &amp;lt; m; j++) {
			if (virus_map[i][j] == 0) count_zero++;
		}
	}

	return count_zero;
}


int main() {

	cin &amp;gt;&amp;gt; n &amp;gt;&amp;gt; m;
	vector&amp;lt;int&amp;gt; location_zero;
	for (int i = 0; i &amp;lt; n; i++) {
		for (int j = 0; j &amp;lt; m; j++) {
			cin &amp;gt;&amp;gt; virus_data[i][j];
			if (virus_data[i][j] == 0) location_zero.push_back(i * 10 + j);
		}
	}
	int result = 0;
	int length_zero = location_zero.size();
	int data_temp[3][2] = { {0,0},{0,0},{0,0} };
	for (int i = 0; i &amp;lt; length_zero - 2; i++) {
		data_temp[0][0] = location_zero.at(i) / 10;
		data_temp[0][1] = location_zero.at(i) % 10;
		for (int j = i+1; j &amp;lt; length_zero - 1; j++) {
			data_temp[1][0] = location_zero.at(j) / 10;
			data_temp[1][1] = location_zero.at(j) % 10;
			for (int k = j+1; k &amp;lt; length_zero; k++) {
				data_temp[2][0] = location_zero.at(k) / 10;
				data_temp[2][1] = location_zero.at(k) % 10;
				init_map();
				for (int z = 0; z &amp;lt; 3; z++)
					virus_map[data_temp[z][0]][data_temp[z][1]] = 1;
				result = max(safety_zone(), result);
			}
		}
	}

	cout &amp;lt;&amp;lt; result;
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;</content><author><name></name></author><summary type="html">문제</summary></entry><entry><title type="html">BOJ 1003 피보나치 함수</title><link href="http://localhost:4000/posts/2017/12/01/BOJ1003.html" rel="alternate" type="text/html" title="BOJ 1003 피보나치 함수" /><published>2017-12-01T12:20:00+09:00</published><updated>2017-12-01T12:20:00+09:00</updated><id>http://localhost:4000/posts/2017/12/01/BOJ1003</id><content type="html" xml:base="http://localhost:4000/posts/2017/12/01/BOJ1003.html">&lt;p&gt;&lt;br /&gt;&lt;/p&gt;
&lt;h1 id=&quot;문제&quot;&gt;&lt;a href=&quot;https://www.acmicpc.net/problem/1003&quot;&gt;문제&lt;/a&gt;&lt;/h1&gt;

&lt;p&gt;&lt;br /&gt;
다음 소스는 N번째 피보나치 함수를 구하는 함수이다.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;int fibonacci(int n) {
    if (n==0) {
        printf(&quot;0&quot;);
        return 0;
    } else if (n==1) {
        printf(&quot;1&quot;);
        return 1;
    } else {
        return fibonacci(n‐1) + fibonacci(n‐2);
    }
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;fibonacci(3)을 호출하면 다음과 같은 일이 일어난다.&lt;/p&gt;

&lt;p&gt;fibonacci(3)은 fibonacci(2)와 fibonacci(1) (첫 번째 호출)을 호출한다.&lt;/p&gt;

&lt;p&gt;fibonacci(2)는 fibonacci(1) (두 번째 호출)과 fibonacci(0)을 호출한다.&lt;/p&gt;

&lt;p&gt;두 번째 호출한 fibonacci(1)은 1을 출력하고 1을 리턴한다.&lt;/p&gt;

&lt;p&gt;fibonacci(0)은 0을 출력하고, 0을 리턴한다.&lt;/p&gt;

&lt;p&gt;fibonacci(2)는 fibonacci(1)과 fibonacci(0)의 결과를 얻고, 1을 리턴한다.&lt;/p&gt;

&lt;p&gt;첫 번째 호출한 fibonacci(1)은 1을 출력하고, 1을 리턴한다.&lt;/p&gt;

&lt;p&gt;fibonacci(3)은 fibonacci(2)와 fibonacci(1)의 결과를 얻고, 2를 리턴한다.&lt;/p&gt;

&lt;p&gt;이 때, 1은 2번 출력되고, 0은 1번 출력된다. N이 주어졌을 때, fibonacci(N)을 호출했을 때, 0과 1이 각각 몇 번 출력되는지 구하는 프로그램을 작성하시오.
&lt;br /&gt;&lt;/p&gt;
&lt;h1 id=&quot;입력&quot;&gt;입력&lt;/h1&gt;
&lt;p&gt;&lt;br /&gt;
첫째 줄에 테스트 케이스의 개수 T가 주어진다. 각 테스트 케이스는 다음과 같이 구성되어있다.&lt;/p&gt;

&lt;p&gt;첫째 줄에 N이 주어진다. N은 40보다 작거나 같은 자연수 또는 0이다.
&lt;br /&gt;&lt;/p&gt;
&lt;h1 id=&quot;출력&quot;&gt;출력&lt;/h1&gt;
&lt;p&gt;&lt;br /&gt;
각 테스트 케이스마다 0이 출력되는 횟수와 1이 출력되는 횟수를 공백으로 구분해서 출력한다.
&lt;br /&gt;&lt;/p&gt;
&lt;h1 id=&quot;해결-방법&quot;&gt;해결 방법&lt;/h1&gt;
&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;함수를 보면 재귀호출로 n-1,n-2의 값을 호출한다. 그 말의 의미는 그 전 값들을 이용하면 재귀 호출 없이 그것들을 알 수 있게 된다.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;이는 DP에서 Bottom-Up 방식으로 데이터를 하나하나 차곡차곡 쌓으면 된다.&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;
&lt;h1 id=&quot;코드&quot;&gt;코드&lt;/h1&gt;
&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;#include &amp;lt;iostream&amp;gt;
#include &amp;lt;algorithm&amp;gt;
using namespace std;
int dp[41][2];
int main() {
	int T;
	cin &amp;gt;&amp;gt; T;
	int *arr = new int[T];
	for (int i = 0; i &amp;lt; T; i++)
	{
		cin &amp;gt;&amp;gt; arr[i];
	}

	dp[0][0] = 1; dp[0][1] = 0;
	dp[1][0] = 0; dp[1][1] = 1;
	
	for (int i = 2; i &amp;lt;= 40; i++)
	{
		for (int j = 0; j &amp;lt; 2; j++)
			dp[i][j] = dp[i - 1][j] + dp[i - 2][j];
	}

	for (int i = 0; i &amp;lt; T; i++)
	{
		for (int j = 0; j &amp;lt; 2; j++)
			cout &amp;lt;&amp;lt; dp[arr[i]][j] &amp;lt;&amp;lt; &quot; &quot;;
		cout &amp;lt;&amp;lt; endl;
	}
}	
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;</content><author><name></name></author><summary type="html">문제</summary></entry><entry><title type="html">BOJ 3613 Java vs C++</title><link href="http://localhost:4000/posts/2017/11/30/BOJ3613.html" rel="alternate" type="text/html" title="BOJ 3613 Java vs C++" /><published>2017-11-30T10:00:00+09:00</published><updated>2017-11-30T10:00:00+09:00</updated><id>http://localhost:4000/posts/2017/11/30/BOJ3613</id><content type="html" xml:base="http://localhost:4000/posts/2017/11/30/BOJ3613.html">&lt;p&gt;&lt;br /&gt;&lt;/p&gt;
&lt;h1 id=&quot;문제&quot;&gt;&lt;a href=&quot;https://www.acmicpc.net/problem/3613&quot;&gt;문제&lt;/a&gt;&lt;/h1&gt;

&lt;p&gt;&lt;br /&gt;
Java 예찬론자 김동규와 C++ 옹호가 김동혁은 서로 어떤 프로그래밍 언어가 최고인지 몇 시간동안 토론을 하곤 했다. 동규는 Java가 명확하고 에러가 적은 프로그램을 만든다고 주장했고, 동혁이는 Java는 프로그램이 느리고, 긴 소스 코드를 갖는 점과 제네릭 배열의 인스턴스화의 무능력을 비웃었다.&lt;/p&gt;

&lt;p&gt;또, 김동규와 김동혁은 변수 이름을 짓는 방식도 서로 달랐다. Java에서는 변수의 이름이 여러 단어로 이루어져있을 때, 다음과 같은 방법으로 변수명을 짓는다.&lt;/p&gt;

&lt;p&gt;첫 단어는 소문자로 쓰고, 다음 단어부터는 첫 문자만 대문자로 쓴다. 또, 모든 단어는 붙여쓴다. 따라서 Java의 변수명은 javaIdentifier, longAndMnemonicIdentifier, name, bAEKJOON과 같은 형태이다.&lt;/p&gt;

&lt;p&gt;반면에 C++에서는 변수명에 소문자만 사용한다. 단어와 단어를 구분하기 위해서 밑줄(‘_‘)을 이용한다. C++ 변수명은 c_identifier, long_and_mnemonic_identifier, name, b_a_e_k_j_o_o_n과 같은 형태이다.&lt;/p&gt;

&lt;p&gt;이 둘의 싸움을 부질없다고 느낀 재원이는 C++형식의 변수명을 Java형식의 변수명으로, 또는 그 반대로 바꿔주는 프로그램을 만드려고 한다. 각 언어의 변수명 형식의 위의 설명을 따라야 한다.&lt;/p&gt;

&lt;p&gt;재원이의 프로그램은 가장 먼저 변수명을 입력으로 받은 뒤, 이 변수명이 어떤 언어 형식인지를 알아내야 한다. 그 다음, C++형식이라면 Java형식으로, Java형식이라면 C++형식으로 바꾸면 된다. 만약 C++형식과 Java형식 둘 다 아니라면, 에러를 발생시킨다. 변수명을 변환할 때, 단어의 순서는 유지되어야 한다.&lt;/p&gt;

&lt;p&gt;재원이는 프로그램을 만드려고 했으나, 너무 귀찮은 나머지 이를 문제를 읽는 사람의 몫으로 맡겨놨다.&lt;/p&gt;

&lt;p&gt;재원이가 만드려고 한 프로그램을 대신 만들어보자.
&lt;br /&gt;&lt;/p&gt;
&lt;h1 id=&quot;입력&quot;&gt;입력&lt;/h1&gt;
&lt;p&gt;&lt;br /&gt;
첫째 줄에 변수명이 주어진다. 영어 알파벳과 밑줄(‘_‘)로만 이루어져 있고, 길이는 100을 넘지 않는다.
&lt;br /&gt;&lt;/p&gt;
&lt;h1 id=&quot;출력&quot;&gt;출력&lt;/h1&gt;
&lt;p&gt;&lt;br /&gt;
입력으로 주어진 변수명이 Java형식이면, C++형식으로 출력하고, C++형식이라면 Java형식으로 출력한다. 둘 다 아니라면 “Error!”를 출력한다.
&lt;br /&gt;&lt;/p&gt;
&lt;h1 id=&quot;해결-방법&quot;&gt;해결 방법&lt;/h1&gt;
&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;String을 C++로 처리하는 건 자바보다 불편하다고 하지만 해봤다.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Java 케이스는 맨 앞에 대문자가 들어가지 않는 대소 문자로 이루어진 케이스이다.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;C++ 케이스는 맨 앞과 맨뒤에 ‘&lt;em&gt;‘가 들어가지 않는 ‘&lt;/em&gt;‘와 소문자로 이루어진 케이스이다.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;엄청 여러번 제출하게 되었는데 그 이유는 ‘_‘가 두번 연속으로 나오는 케이스는 Error이기 때문이다. Java 케이스의 경우 연속적으로 대문자가 두번 나와도 가능하다.&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;
&lt;h1 id=&quot;코드&quot;&gt;코드&lt;/h1&gt;
&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;#include &amp;lt;string&amp;gt;
#include &amp;lt;iostream&amp;gt;

using namespace std;

int main(){
  string input_data;
  cin &amp;gt;&amp;gt; input_data;

  int input_data_size = input_data.length();
  int flags= 0;

  if (input_data.find(&quot;_&quot;) != -1) {
      flags=1;
  }


  int flags_=0;
  string result=&quot;&quot;;
  int temp_int = 'a' - 'A';
  int temp_int2 = 'A' - 'a';

  for(int i =0;i&amp;lt;input_data_size;i++){

    char temp_char = input_data.at(i);

	if (((i == 0 || i == input_data_size-1) &amp;amp;&amp;amp; (temp_char == '_'))|| (i==0 &amp;amp;&amp;amp; temp_char &amp;gt;= 'A' &amp;amp;&amp;amp; temp_char &amp;lt;= 'Z')) {
		result = &quot;Error!&quot;;
		break;
	}
	
    if(temp_char &amp;gt;= 'a' &amp;amp;&amp;amp; temp_char &amp;lt;= 'z'){
      if(flags_ == 1){
        temp_char += temp_int2;
        flags_=0;
      }
        result += temp_char;
    }
    else if(temp_char &amp;gt;= 'A' &amp;amp;&amp;amp; temp_char &amp;lt;= 'Z'){
      if(flags == 0){
		  temp_char += temp_int;
		  result += '_';
		  result += temp_char;
      }else {
		result = &quot;Error!&quot;;
        break;
      }
    }else if(flags==1){
      if(temp_char=='_' &amp;amp;&amp;amp; flags_ ==0){
		  flags_ = 1;
	  }else {
		  result = &quot;Error!&quot;;
		  break;
      }
	}
  }

  cout&amp;lt;&amp;lt;result;
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;</content><author><name></name></author><summary type="html">문제</summary></entry><entry><title type="html">BOJ 2579 계단 오르기</title><link href="http://localhost:4000/posts/2017/11/29/BOJ2579.html" rel="alternate" type="text/html" title="BOJ 2579  계단 오르기" /><published>2017-11-29T14:58:00+09:00</published><updated>2017-11-29T14:58:00+09:00</updated><id>http://localhost:4000/posts/2017/11/29/BOJ2579</id><content type="html" xml:base="http://localhost:4000/posts/2017/11/29/BOJ2579.html">&lt;p&gt;&lt;br /&gt;&lt;/p&gt;
&lt;h1 id=&quot;문제&quot;&gt;&lt;a href=&quot;https://www.acmicpc.net/problem/2579&quot;&gt;문제&lt;/a&gt;&lt;/h1&gt;

&lt;p&gt;&lt;br /&gt;
계단 오르기 게임은 계단 아래 시작점부터 계단 꼭대기에 위치한 도착점까지 가는 게임이다. &amp;lt;그림 1&amp;gt;과 같이 각각의 계단에는 일정한 점수가 쓰여 있는데 계단을 밟으면 그 계단에 쓰여 있는 점수를 얻게 된다.&lt;/p&gt;

&lt;p&gt;예를 들어 &amp;lt;그림 2&amp;gt;와 같이 시작점에서부터 첫 번째, 두 번째, 네 번째, 여섯 번째, 계단을 밟아 도착점에 도달하면 총 점수는 10 + 20 + 25 + 20 = 75점이 된다.&lt;/p&gt;

&lt;p&gt;계단 오르는 데는 다음과 같은 규칙이 있다.&lt;/p&gt;

&lt;p&gt;계단은 한 번에 한 계단씩 또는 두 계단씩 오를 수 있다. 즉, 한 계단을 밟으면서 이어서 다음 계단이나, 다음 다음 계단으로 오를 수 있다.
연속된 세 개의 계단을 모두 밟아서는 안된다. 단, 시작점은 계단에 포함되지 않는다.
마지막 도착 계단은 반드시 밟아야 한다.
따라서 첫 번째 계단을 밟고 이어 두 번째 계단이나, 세 번째 계단으로 오를 수 있다. 하지만, 첫 번째 계단을 밟고 이어 네 번째 계단으로 올라가거나, 첫 번째, 두 번째, 세번째 계단을 연속해서 모두 밟을 수는 없다.&lt;/p&gt;

&lt;p&gt;각 계단에 쓰여 있는 점수가 주어질 때 이 게임에서 얻을 수 있는 총 점수의 최대값을 구하는 프로그램을 작성하시오.
&lt;br /&gt;&lt;/p&gt;
&lt;h1 id=&quot;입력&quot;&gt;입력&lt;/h1&gt;
&lt;p&gt;&lt;br /&gt;
입력의 첫째 줄에 계단의 개수가 주어진다.&lt;/p&gt;

&lt;p&gt;둘째 줄부터 한 줄에 하나씩 제일 아래에 놓인 계단부터 순서대로 각 계단에 쓰여 있는 점수가 주어진다. 계단의 개수는 300이하의 자연수이고, 계단에 쓰여 있는 점수는 10,000이하의 자연수이다.
&lt;br /&gt;&lt;/p&gt;
&lt;h1 id=&quot;출력&quot;&gt;출력&lt;/h1&gt;
&lt;p&gt;&lt;br /&gt;
첫째 줄에 계단 오르기 게임에서 얻을 수 있는 총 점수의 최대값을 출력한다.
&lt;br /&gt;&lt;/p&gt;
&lt;h1 id=&quot;해결-방법&quot;&gt;해결 방법&lt;/h1&gt;
&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;앞서 포스팅한 2156번 포도주 시식 문제와 매우 유사하다.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;다른 점은 포도주 시식의 경우 최대값을 위해서는 연속해서 2잔 이상을 마시지 않아도 되지만 계단 오르기의 경우 한잔만 건너뛸 수 있다.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;각 위치의 계단은 세가지의 경우를 가진다.
0 = 밟지 않는다. (아래의 계단을 밟았어야한다.)
1 = 아래의 계단은 밟지않고, 이번 계단만 밟는다. (즉, 2계단 위를 밟았다.)
2 = 아래의 계단을 밟고, 이번 계단도 밟는다. (즉, 1계단 위를 밟는다.)&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;위의 세가지 경우를 데이터에 저장하고, 이를 이용하여 최대값을 구하면 된다.&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;
&lt;h1 id=&quot;코드&quot;&gt;코드&lt;/h1&gt;
&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;#include &amp;lt;iostream&amp;gt;

using namespace std;

int dp[301][3];
int stairs[301];

int main(){
  int n;
  cin&amp;gt;&amp;gt;n;
  for(int i =1;i&amp;lt;=n;i++)
    cin&amp;gt;&amp;gt;stairs[i];

  for(int i=1;i&amp;lt;n;i++){
    dp[i][0] = max(dp[i-1][1],dp[i-1][2]); // i 위치는 밟지 않는 경우 //한 계단 or 두 계단 전은 밟아야함
    dp[i][1] = dp[i-1][0]+stairs[i]; //밟는 경우 중 연속 계수가 1
    dp[i][2] = dp[i-1][1]+stairs[i]; // 밟는 경우 중 연속 계수가 2
  }
  int result =  max(dp[n-1][1],dp[n-1][0]) + stairs[n];
  cout&amp;lt;&amp;lt;result&amp;lt;&amp;lt;&quot;\n&quot;;

}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;</content><author><name></name></author><summary type="html">문제</summary></entry><entry><title type="html">BOJ 2156 포도주 시식</title><link href="http://localhost:4000/posts/2017/11/29/BOJ2156.html" rel="alternate" type="text/html" title="BOJ 2156 포도주 시식" /><published>2017-11-29T14:51:00+09:00</published><updated>2017-11-29T14:51:00+09:00</updated><id>http://localhost:4000/posts/2017/11/29/BOJ2156</id><content type="html" xml:base="http://localhost:4000/posts/2017/11/29/BOJ2156.html">&lt;p&gt;&lt;br /&gt;&lt;/p&gt;
&lt;h1 id=&quot;문제&quot;&gt;&lt;a href=&quot;https://www.acmicpc.net/problem/2156&quot;&gt;문제&lt;/a&gt;&lt;/h1&gt;

&lt;p&gt;&lt;br /&gt;
효주는 포도주 시식회에 갔다. 그 곳에 갔더니, 테이블 위에 다양한 포도주가 들어있는 포도주 잔이 일렬로 놓여 있었다. 효주는 포도주 시식을 하려고 하는데, 여기에는 다음과 같은 두 가지 규칙이 있다.&lt;/p&gt;

&lt;p&gt;포도주 잔을 선택하면 그 잔에 들어있는 포도주는 모두 마셔야 하고, 마신 후에는 원래 위치에 다시 놓아야 한다.
연속으로 놓여 있는 3잔을 모두 마실 수는 없다.
효주는 될 수 있는 대로 많은 양의 포도주를 맛보기 위해서 어떤 포도주 잔을 선택해야 할지 고민하고 있다. 1부터 n까지의 번호가 붙어 있는 n개의 포도주 잔이 순서대로 테이블 위에 놓여 있고, 각 포도주 잔에 들어있는 포도주의 양이 주어졌을 때, 효주를 도와 가장 많은 양의 포도주를 마실 수 있도록 하는 프로그램을 작성하시오.&lt;/p&gt;

&lt;p&gt;예를 들어 6개의 포도주 잔이 있고, 각각의 잔에 순서대로 6, 10, 13, 9, 8, 1 만큼의 포도주가 들어 있을 때, 첫 번째, 두 번째, 네 번째, 다섯 번째 포도주 잔을 선택하면 총 포도주 양이 33으로 최대로 마실 수 있다.
&lt;br /&gt;&lt;/p&gt;
&lt;h1 id=&quot;입력&quot;&gt;입력&lt;/h1&gt;
&lt;p&gt;&lt;br /&gt;
첫째 줄에 포도주 잔의 개수 n이 주어진다. (1≤n≤10,000) 둘째 줄부터 n+1번째 줄까지 포도주 잔에 들어있는 포도주의 양이 순서대로 주어진다. 포도주의 양은 1,000 이하의 음이 아닌 정수이다.
&lt;br /&gt;&lt;/p&gt;
&lt;h1 id=&quot;출력&quot;&gt;출력&lt;/h1&gt;
&lt;p&gt;&lt;br /&gt;
첫째 줄에 최대로 마실 수 있는 포도주의 양을 출력한다.
&lt;br /&gt;&lt;/p&gt;
&lt;h1 id=&quot;해결-방법&quot;&gt;해결 방법&lt;/h1&gt;
&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;n에 들어 올 수 잇는 수는 1&amp;lt;=n&amp;lt;=10,000 이개 때문에 O(n^2)으로 할 경우에 시간 초과가 발생한다.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;그렇다면 포도주를 마시면서 그것의 대한 값을 데이터 저정해야한다.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;각 위치의 포도주는 세가지의 경우를 가진다. 0 = 마시지 않는다.
1 = 바로 왼쪽 옆 잔은 마시지 않았으나 이번 잔은 마신다.
2 = 바로 왼쪽 옆 잔도 마셨고, 이번 잔도 마신다 (단,왼쪽으로 두번째 옆 잔은 마시지 않았다.)&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;위의 세가지 경우를 데이터에 저장하고, 이를 이용하여 최대값을 구하면 된다.&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;
&lt;h1 id=&quot;코드&quot;&gt;코드&lt;/h1&gt;
&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;#include &amp;lt;iostream&amp;gt;
#include &amp;lt;algorithm&amp;gt;
using namespace std;

int dp[10001][4];
int wine_data[10001];

int main(){
	int wine_count;
	cin&amp;gt;&amp;gt;wine_count;
	for(int i=1;i&amp;lt;=wine_count;i++)
		cin&amp;gt;&amp;gt;wine_data[i];
	for(int i=1;i&amp;lt;=wine_count;i++){
		dp[i][0]= dp[i-1][3];
		dp[i][1]= dp[i-1][0]+wine_data[i];
		dp[i][2]= dp[i-1][1]+wine_data[i];
		dp[i][3]= max(dp[i][0],max(dp[i][1],dp[i][2]));
	}

	cout&amp;lt;&amp;lt;dp[wine_count][3]&amp;lt;&amp;lt;&quot;\n&quot;;

}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;</content><author><name></name></author><summary type="html">문제</summary></entry><entry><title type="html">BOJ 9095 1,2,3 더하기</title><link href="http://localhost:4000/posts/2017/11/28/BOJ9095.html" rel="alternate" type="text/html" title="BOJ 9095 1,2,3 더하기" /><published>2017-11-28T07:51:00+09:00</published><updated>2017-11-28T07:51:00+09:00</updated><id>http://localhost:4000/posts/2017/11/28/BOJ9095</id><content type="html" xml:base="http://localhost:4000/posts/2017/11/28/BOJ9095.html">&lt;p&gt;&lt;br /&gt;&lt;/p&gt;
&lt;h1 id=&quot;문제&quot;&gt;&lt;a href=&quot;https://www.acmicpc.net/problem/9095&quot;&gt;문제&lt;/a&gt;&lt;/h1&gt;
&lt;p&gt;&lt;br /&gt;
정수 4를 1, 2, 3의 조합으로 나타내는 방법은 총 7가지가 있다.&lt;/p&gt;

&lt;p&gt;1+1+1+1
1+1+2
1+2+1
2+1+1
2+2
1+3
3+1
정수 n이 주어졌을 때, n을 1,2,3의 합으로 나타내는 방법의 수를 구하는 프로그램을 작성하시오.
&lt;br /&gt;&lt;/p&gt;
&lt;h1 id=&quot;입력&quot;&gt;입력&lt;/h1&gt;
&lt;p&gt;&lt;br /&gt;
첫쨰 줄에 테스트 케이스의 개수 T가 주어진다. 각 테스트 케이스는 한 줄로 이루어져 있고, 정수 n이 주어진다. n은 양수이며 11보다 작다.
&lt;br /&gt;&lt;/p&gt;
&lt;h1 id=&quot;출력&quot;&gt;출력&lt;/h1&gt;
&lt;p&gt;&lt;br /&gt;
각 테스트 케이스마다, n을 1,2,3의 합으로 나타내는 방법의 수를 출력한다.
&lt;br /&gt;&lt;/p&gt;
&lt;h1 id=&quot;해결-방법&quot;&gt;해결 방법&lt;/h1&gt;
&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;1,2,3을 이용하여 1~11 가지의 숫자의 경우의 수를 구하는 것이다. 여기서 포인트는 무엇보다 숫자에 순서가 중요하다는 것이다. 그것을 이용하면 쉽게 문제를 해결할 수 있다.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;예로 나와있듯이 4를 구성하는 경우는 총 7가지가 존재한다.
이것을 보면 3을 구성하는 경우의수와 2를 구성하는 경우의 수와 1을 구성하는 경우의 수를 더한 값과 같다.&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;
&lt;h1 id=&quot;코드&quot;&gt;코드&lt;/h1&gt;
&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;#include &amp;lt;iostream&amp;gt;
#include &amp;lt;string&amp;gt;

using namespace std;
int dp[11];
int num[3]={1,2,3};

int main(){
  dp[0] = 0;

  int n;
  cin &amp;gt;&amp;gt;n;

  for(int i=1;i&amp;lt;11;i++){
    for(int j=0;j&amp;lt;3;j++){
      if( i - num[j] &amp;gt;= 1){
        dp[i]+= dp[i-num[j]];
      }
      if(num[j]==i){
        dp[i]+=1;
      }
    }
  }
  for (int i = 0; i &amp;lt; n; i++) {
	  int temp;
	  cin &amp;gt;&amp;gt; temp;
	  cout &amp;lt;&amp;lt; dp[temp] &amp;lt;&amp;lt; &quot;\n&quot;;
  }

}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;</content><author><name></name></author><summary type="html">문제 정수 4를 1, 2, 3의 조합으로 나타내는 방법은 총 7가지가 있다.</summary></entry><entry><title type="html">BOJ 2133 타일 채우기</title><link href="http://localhost:4000/posts/2017/11/27/BOJ2133.html" rel="alternate" type="text/html" title="BOJ 2133 타일 채우기" /><published>2017-11-27T08:51:00+09:00</published><updated>2017-11-27T08:51:00+09:00</updated><id>http://localhost:4000/posts/2017/11/27/BOJ2133</id><content type="html" xml:base="http://localhost:4000/posts/2017/11/27/BOJ2133.html">&lt;p&gt;&lt;br /&gt;&lt;/p&gt;
&lt;h1 id=&quot;문제&quot;&gt;&lt;a href=&quot;https://www.acmicpc.net/problem/2133&quot;&gt;문제&lt;/a&gt;&lt;/h1&gt;
&lt;p&gt;&lt;br /&gt;
3×N 크기의 벽을 2×1, 1×2 크기의 타일로 채우는 경우의 수를 구해보자.
&lt;br /&gt;&lt;/p&gt;
&lt;h1 id=&quot;입력&quot;&gt;입력&lt;/h1&gt;
&lt;p&gt;&lt;br /&gt;
첫째 줄에 N(1 ≤ N ≤ 30)이 주어진다.
&lt;br /&gt;&lt;/p&gt;
&lt;h1 id=&quot;출력&quot;&gt;출력&lt;/h1&gt;
&lt;p&gt;&lt;br /&gt;
첫째 줄에 경우의 수를 출력한다.
&lt;br /&gt;&lt;/p&gt;
&lt;h1 id=&quot;해결-방법&quot;&gt;해결 방법&lt;/h1&gt;
&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;홀수 일때의 값은 신경쓸 필요가 없다. 모든 홀수의 경우는 0이다.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;N = 2 일때, 3개의 경우의 수가 발생하고, 3×2 타일을 이어 붙였을 때, 경계에서 2개의 새로운 경우의 수가 발생한다. 이 새로운 경우를 F케이스로 명명하자.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;즉, 각 N 값은 3×N-2 를 완성한 경우에서 3×2 타일의 붙이는 경우의 수와 N-j (4&amp;lt;=j&amp;lt;=N (j+2))인 K케이스에  발생하는 경우의 수를 합하면 해결된다.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;6을 예로 하면, 3×4 타일의 경우의 수인 11 *3 과 3x4타일에 새로운 타일을 붙일 때 만들어지는 K케이스는 3x4타일에서 K케이스가 없을 때와 있을 때로 나누어 보면 3 *2 + 1 *2 의 값이 나온다.&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;
&lt;h1 id=&quot;코드&quot;&gt;코드&lt;/h1&gt;
&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;#include &amp;lt;iostream&amp;gt;
using namespace std;

int index[31];

int main() {
	int n = 0;
	cin &amp;gt;&amp;gt; n;

	int result = 0;
	index[0] = 1;
	index[2] = 3;
	
	for (int i = 4; i &amp;lt;= n; i += 2) {
		index[i] += index[i - 2] * index[2]; // 3*i-2로 만들어진 타일에 3*2의 타일을 추가할 경우의 수

		for (int j = 4; j &amp;lt;= i; j++) {
			index[i] += index[i - j] * 2; // 3*2타일들이 붙었을 때, 그 사이에 2개 만큼의 경우의 수가 추가 발생
		}
	}
	cout &amp;lt;&amp;lt; index[n];
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;</content><author><name></name></author><summary type="html">문제 3×N 크기의 벽을 2×1, 1×2 크기의 타일로 채우는 경우의 수를 구해보자. 입력 첫째 줄에 N(1 ≤ N ≤ 30)이 주어진다. 출력 첫째 줄에 경우의 수를 출력한다. 해결 방법</summary></entry><entry><title type="html">BOJ 14501 퇴사</title><link href="http://localhost:4000/posts/2017/11/21/BOJ14501.html" rel="alternate" type="text/html" title="BOJ 14501 퇴사" /><published>2017-11-21T14:30:00+09:00</published><updated>2017-11-21T14:30:00+09:00</updated><id>http://localhost:4000/posts/2017/11/21/BOJ14501</id><content type="html" xml:base="http://localhost:4000/posts/2017/11/21/BOJ14501.html">&lt;p&gt;&lt;br /&gt;&lt;/p&gt;
&lt;h1 id=&quot;문제&quot;&gt;&lt;a href=&quot;https://www.acmicpc.net/problem/14501&quot;&gt;문제&lt;/a&gt;&lt;/h1&gt;
&lt;p&gt;&lt;br /&gt;
상담원으로 일하고 있는 백준이는 퇴사를 하려고 한다.&lt;/p&gt;

&lt;p&gt;오늘부터 N+1일째 되는날 퇴사를 하기 위해서, 남은 N일 동안 최대한 많은 상담을 하려고 한다.&lt;/p&gt;

&lt;p&gt;백준이는 비서에게 최대한 많은 상담을 잡으라고 부탁을 했고, 비서는 하루에 하나씩 서로 다른 사람의 상담을 잡아놓았다.&lt;/p&gt;

&lt;p&gt;각각의 상담은 상담을 완료하는데 걸리는 기간 Ti와 상담을 했을 때 받을 수 있는 금액 Pi로 이루어져 있다.&lt;/p&gt;

&lt;p&gt;N = 7인 경우에 다음과 같은 상담 일정표를 보자.
&lt;br /&gt;&lt;br /&gt;&lt;/p&gt;
&lt;pre&gt;
 	1일	2일	3일	4일	5일	6일	7일
Ti	3	5	1	1	2	4	2
Pi	10	20	10	20	15	40	200
&lt;/pre&gt;
&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;1일에 잡혀있는 상담은 총 3일이 걸리며, 상담했을 때 받을 수 있는 금액은 10이다. 5일에 잡혀있는 상담은 총 2일이 걸리며, 받을 수 있는 금액은 15이다.&lt;/p&gt;

&lt;p&gt;상담을 하는데 필요한 기간은 1일보다 클 수 있기 때문에, 모든 상담을 할 수는 없다. 예를 들어서 1일에 상담을 하게 되면, 2일, 3일에 있는 상담은 할 수 없게 된다. 2일에 있는 상담을 하게 되면, 3, 4, 5, 6일에 잡혀있는 상담은 할 수 없다.&lt;/p&gt;

&lt;p&gt;또한, N+1일 째에는 회사에 없기 때문에, 6, 7일에 있는 상담을 할 수 없다.&lt;/p&gt;

&lt;p&gt;퇴사 전에 할 수 있는 상담의 최대 이익은 1일, 4일, 5일에 있는 상담을 하는 것이며, 이 때의 이익은 10+20+15=45이다.&lt;/p&gt;

&lt;p&gt;상담을 적절히 했을 때, 백준이가 얻을 수 있는 최대 수익을 구하는 프로그램을 작성하시오.
&lt;br /&gt;&lt;/p&gt;
&lt;h1 id=&quot;입력&quot;&gt;입력&lt;/h1&gt;
&lt;p&gt;&lt;br /&gt;
첫째 줄에 N (1 ≤ N ≤ 15)이 주어진다.&lt;/p&gt;

&lt;p&gt;둘째 줄부터 N개의 줄에 Ti와 Pi가 공백으로 구분되어서 주어지며, 1일부터 N일까지 순서대로 주어진다. (1 ≤ Ti ≤ 5, 1 ≤ Pi ≤ 1,000)
&lt;br /&gt;&lt;/p&gt;
&lt;h1 id=&quot;출력&quot;&gt;출력&lt;/h1&gt;
&lt;p&gt;&lt;br /&gt;
첫째 줄에 백준이가 얻을 수 있는 최대 이익을 출력한다.
&lt;br /&gt;&lt;/p&gt;
&lt;h1 id=&quot;해결-방법&quot;&gt;해결 방법&lt;/h1&gt;
&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;최대 이익을 찾으려는 것이다. 근데 데이터 셋이 크지 않다는 것이 이번 문제를 푸는 가장 쉬운 접근 법이다. 즉, 완전 탐색을 해도 된다는 것이다. 하지만 그래도 효율적으로 접근하기위해 배열에 값을 저장하여 사용하는 DP의 방법인 메모리제이션을 이용하였다.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;점화식으로 포문을 이용하여서 푸는 방법이 내 생각에는 더 효율적으로 보이지만 점화식을 잘 모르겠다.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;디피의 0번째 부터 채워가는 바텀업도 아니구, 끝에서 부터 만들어 나가는 탑다운도 아니다. 그냥 재귀호출을 통해 해결해나가는 것이고, 어떻게 보면 깊이우선탐색으로도 보일 수 있다.&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;
&lt;h1 id=&quot;코드&quot;&gt;코드&lt;/h1&gt;
&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;import java.util.Scanner;

public class BOJ14501 {

static int[][] dp;
static int[][] data;
static int day;
public static void main(String args[]){
    Scanner sc = new Scanner(System.in);
    day = sc.nextInt();
    dp = new int[day+1][2];
    data = new int[day][2];

    for(int i=0;i&amp;lt;day;i++){
        data[i][0]= sc.nextInt();
        data[i][1]= sc.nextInt();
        dp[i][0]=-1;
        dp[i][1]=-1;
    }
    int result = 0;

    result = DFS(0);
    System.out.println(result);
    sc.close();
}

static int DFS(int index){
    int result=0;

    if(dp[index][0]!=-1){
        if(dp[index][0]&amp;gt;dp[index][1]){
            return  dp[index][0];
        }else return dp[index][1];
    }

    if(index-1 &amp;gt;= day){
        return 0;
    }

    dp[index][0] = DFS(index+1);
    if(data[index][0]+index-1 &amp;lt; day) {
        dp[index][1] = DFS(index + data[index][0]) + data[index][1];
    }else{
        dp[index][1] = 0;
    }

    if(dp[index][0]&amp;gt;dp[index][1]){
        result += dp[index][0];
    }else result+= dp[index][1];

    return result;
} }
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;</content><author><name></name></author><summary type="html">문제 상담원으로 일하고 있는 백준이는 퇴사를 하려고 한다.</summary></entry><entry><title type="html">BOJ 2293 동전 1</title><link href="http://localhost:4000/posts/2017/11/20/BOJ2293.html" rel="alternate" type="text/html" title="BOJ 2293 동전 1" /><published>2017-11-20T07:30:00+09:00</published><updated>2017-11-20T07:30:00+09:00</updated><id>http://localhost:4000/posts/2017/11/20/BOJ2293</id><content type="html" xml:base="http://localhost:4000/posts/2017/11/20/BOJ2293.html">&lt;p&gt;&lt;br /&gt;&lt;/p&gt;
&lt;h1 id=&quot;문제&quot;&gt;&lt;a href=&quot;https://www.acmicpc.net/problem/2293&quot;&gt;문제&lt;/a&gt;&lt;/h1&gt;
&lt;p&gt;&lt;br /&gt;
n가지 종류의 동전이 있다. 각각의 동전이 나타내는 가치는 다르다. 이 동전들을 적당히 사용해서, 그 가치의 합이 k원이 되도록 하고 싶다. 그 경우의 수를 구하시오. (각각의 동전은 몇 개라도 사용할 수 있다.)
&lt;br /&gt;&lt;/p&gt;
&lt;h1 id=&quot;입력&quot;&gt;입력&lt;/h1&gt;
&lt;p&gt;&lt;br /&gt;
첫째줄에 n, k가 주어진다. (1 ≤ n ≤ 100, 1 ≤ k ≤ 10,000) 다음 n개의 줄에는 각각의 동전의 가치가 주어진다.
&lt;br /&gt;&lt;/p&gt;
&lt;h1 id=&quot;출력&quot;&gt;출력&lt;/h1&gt;
&lt;p&gt;&lt;br /&gt;
첫째 줄에 경우의 수를 출력한다. 경우의 수는 2^31보다 작다.
&lt;br /&gt;&lt;/p&gt;
&lt;h1 id=&quot;해결-방법&quot;&gt;해결 방법&lt;/h1&gt;
&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;찾으려는 수는 (찾으려는 수 - 동전의 값) 들의 합이다.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;중복이 되면 안된다.&lt;/p&gt;
    &lt;blockquote&gt;
      &lt;p&gt;예를 들어 1과 2로 5를 만들려고 할때, 1112 1121 1211 2111 은 순서 다르고 다 같은 값을 만들게 된다. 따라서 중복을 제거하기 위해 중복을 안만드는 방법을 선택하였다. &lt;br /&gt;
그 방법은 가장 값이 낮은 동전 부터 배열을 채워나가는 것이다.&lt;/p&gt;
    &lt;/blockquote&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;
&lt;h1 id=&quot;코드&quot;&gt;코드&lt;/h1&gt;
&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;

public class Main {

static int[] dp;
static int[] coins;
static int coinsCounts;
public static void main(String args[]) throws IOException{
    dp = new int [10001];
    for(int i=0;i&amp;lt;10001;i++){
        dp[i] = 0;
    }

    BufferedReader bf = new BufferedReader(new InputStreamReader(System.in));

    String[] line = bf.readLine().split(&quot; &quot;);
    coinsCounts = Integer.valueOf(line[0]);
    int findValue = Integer.valueOf(line[1]);
    coins = new int[coinsCounts];

    for(int i=0;i&amp;lt; coinsCounts;i++){
        coins[i] = Integer.valueOf(bf.readLine());
    }
    dp[0] = 1;
    for(int i=0;i &amp;lt; coinsCounts;i++){
        for(int j=1;j&amp;lt;= findValue ;j++){
            if(j-coins[i] &amp;gt;= 0){
                dp[j] += dp[j-coins[i]];
            }
        }
    }

    System.out.println(dp[findValue]);
    bf.close();
}	
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;</content><author><name></name></author><summary type="html">문제 n가지 종류의 동전이 있다. 각각의 동전이 나타내는 가치는 다르다. 이 동전들을 적당히 사용해서, 그 가치의 합이 k원이 되도록 하고 싶다. 그 경우의 수를 구하시오. (각각의 동전은 몇 개라도 사용할 수 있다.) 입력 첫째줄에 n, k가 주어진다. (1 ≤ n ≤ 100, 1 ≤ k ≤ 10,000) 다음 n개의 줄에는 각각의 동전의 가치가 주어진다. 출력 첫째 줄에 경우의 수를 출력한다. 경우의 수는 2^31보다 작다. 해결 방법</summary></entry><entry><title type="html">About this blog</title><link href="http://localhost:4000/posts/2017/11/18/about.html" rel="alternate" type="text/html" title="About this blog" /><published>2017-11-19T03:30:00+09:00</published><updated>2017-11-19T03:30:00+09:00</updated><id>http://localhost:4000/posts/2017/11/18/about</id><content type="html" xml:base="http://localhost:4000/posts/2017/11/18/about.html">&lt;h2 id=&quot;blog-content&quot;&gt;Blog content&lt;/h2&gt;

&lt;p&gt;I am a computer programmer. &lt;br /&gt;
I am studying for the algorithm contest. &lt;br /&gt;
This is where I write algorithms for algorithms. &lt;br /&gt;&lt;/p&gt;

&lt;h2 id=&quot;introducing-flex-a-jekyll-theme&quot;&gt;Introducing Flex, a Jekyll theme&lt;/h2&gt;

&lt;p&gt;Flex is a minimalist, responsive theme based on the website, &lt;a href=&quot;http://thedevelopment.co&quot;&gt;The Development&lt;/a&gt;.&lt;/p&gt;

&lt;h2 id=&quot;open-sourced-on-github&quot;&gt;Open Sourced on GitHub&lt;/h2&gt;

&lt;p&gt;Flex is open sourced on GitHub and is licensed under the &lt;a href=&quot;http://opensource.org/licenses/MIT&quot;&gt;MIT License&lt;/a&gt;. Feel free to contribute to it anytime!&lt;/p&gt;

&lt;h2 id=&quot;reference&quot;&gt;Reference&lt;/h2&gt;

&lt;p&gt;The theme currently being used was based on &lt;a href=&quot;https://github.com/the-development/flex&quot;&gt;this&lt;/a&gt;&lt;/p&gt;</content><author><name></name></author><summary type="html">Blog content</summary></entry></feed>